/*
  File: /upload/js/processQnA.js
  Description:
    • Processes Q&A text files in the Qapartials folder.
    • Converts a source .txt file (with header lines “##CATEGORY_ID=” and “##TITLE=”,
      followed by numbered question lines) into a Handlebars partial (.handlebars).
    • Generates a Bootstrap accordion matching your manual layout.
    • Designed so you do NOT need to modify your routes or controllers.
    
  IMPORTANT: Below are detailed inline annotations regarding potential fatal mistakes/conflicts/pitfalls:
  
    1. Header Format Dependency:
       • The code assumes the very first two non‐empty lines are exactly “##CATEGORY_ID=” and “##TITLE=”.
       • PITFALL: Extra blank lines or formatting variations in the .txt files will cause the headers to be missed.
       • Recommendation: Either enforce a strict editing rule or add more robust header detection.
    
    2. Regex for Question Detection:
       • The regex /^\d+\.\s+(.+)/ strictly matches a number + dot + at least one space.
       • PITFALL: Questions written like “1) …” or missing a space won’t be detected;
         numbers within answers might be falsely picked up if not properly formatted.
       • Recommendation: Educate contributors to use the exact “1. ” format or upgrade the regex.
    
    3. HTML Escaping and Injection:
       • The script directly inserts the raw text for questions and answers into HTML.
       • PITFALL: Special characters (or malicious content) may break the generated HTML or cause XSS.
       • Recommendation: Consider escaping special characters (or use a templating engine’s built‑in escaping).
    
    4. File System Side Effects:
       • All .txt files in the Qapartials folder are processed.
       • PITFALL: If autogenerated .handlebars files aren’t filtered out, they might be re‑processed.
       • Recommendation: Filter out files that already have a .handlebars extension.
    
    5. Synchronous Operations and Concurrency:
       • fs.readFileSync and fs.writeFileSync are used.
       • PITFALL: With many or large files this might block the event loop (acceptable in build scripts, but be aware).
    
    6. Duplicate or Invalid Category IDs:
       • The script uses the extracted categoryId to generate element IDs in the accordion.
       • PITFALL: Duplicate or non‑sanitized IDs may result in non‑unique HTML elements, breaking your UI.
       • Recommendation: Validate and sanitize category IDs.
    
    7. Deployment Environment Considerations:
       • On environments like Vercel, file writes can be ephemeral.
       • PITFALL: If the conversion runs at runtime (instead of at build time) your partials might not persist.
       • Recommendation: Run this as part of your build/deploy process.
    
    8. Overwriting Manual Changes:
       • Any manual changes made to the generated .handlebars files will be lost on re‑run.
       • PITFALL: This is inherent to auto‑generation. Ensure that the source .txt files are the “single source of truth.”
*/

const fs = require('fs');         // Node.js filesystem module
const path = require('path');       // For resolving cross‐platform paths

// ----------------------------------------------------------------------
// Set Directories
// ----------------------------------------------------------------------
const INPUT_DIR = path.join(process.cwd(), 'Qapartials');  
// Q&A source .txt files must reside in the "Qapartials" folder.
const OUTPUT_DIR = INPUT_DIR; 
// Output partials will be saved in the same folder.
// PITFALL: Using the same folder means you must filter out already generated .handlebars files.

// ----------------------------------------------------------------------
// Function: generateAccordionHTML
// Purpose:
//  • Builds inner HTML for a Bootstrap accordion with Q&A pairs.
// PITFALL: Direct insertion of raw text – consider sanitizing your inputs.
function generateAccordionHTML(categoryId, qnaPairs) {
  let accordionHTML = `<div class="custom-accordion" id="accordion_${categoryId}">\n`;

  qnaPairs.forEach((pair, index) => {
    const itemIndex = index + 1; // User-friendly numbering starts at 1.
    const btnClass = index === 0 ? "btn btn-link" : "btn btn-link collapsed";
    const ariaExpanded = index === 0 ? "true" : "false";
    const collapseClass = index === 0 ? "accordion-collapse collapse show" : "accordion-collapse collapse";

    accordionHTML += `
      <div class="accordion-item">
        <h2 class="mb-0">
          <button class="${btnClass}" 
                  type="button" 
                  data-bs-toggle="collapse" 
                  data-bs-target="#${categoryId}_q${itemIndex}" 
                  aria-expanded="${ariaExpanded}" 
                  aria-controls="${categoryId}_q${itemIndex}">
            ${pair.question.trim()}
          </button>
        </h2>
        <div id="${categoryId}_q${itemIndex}" 
             class="${collapseClass}" 
             aria-labelledby="heading_${categoryId}_${itemIndex}" 
             data-bs-parent="#accordion_${categoryId}">
          <div class="accordion-body">
            <p class="answer">
              ${pair.answer.trim()}
            </p>
          </div>
        </div>
      </div>`;
  });

  accordionHTML += `\n</div>`;
  return accordionHTML;
}

// ----------------------------------------------------------------------
// Function: wrapInCategoryContainer
// Purpose:
//  • Wraps the accordion HTML in the full HTML structure matching your layout.
//  • Inserts a header using the categoryId and title.
// ----------------------------------------------------------------------
function wrapInCategoryContainer(categoryId, title, accordionHTML) {
  return `<div class="mb-8">
  <div class="container">
    <div class="row justify-content-center">
      <div class="col-11 col-xl-10">
        <div class="d-flex align-items-end mb-5">
          <h3 class="m-0" id="${categoryId}">${title}</h3>
        </div>
      </div>
      <div class="col-11 col-xl-10">
        <div class="col-lg-5 mt-4 mt-lg-0" data-aos="fade-up" data-aos-delay="100" style="width: 100% !important;">
${accordionHTML}
        </div>
      </div>
    </div>
  </div>
</div>`;
}

// ----------------------------------------------------------------------
// Function: processFile
// Purpose:
//  • Reads a Q&A .txt file, validates headers, and parses Q&A pairs.
//  • Uses a robust regex (^\d+\.\s+(.+)) to detect new questions.
// PITFALLS:
//    - If the file does not strictly use the expected header or question format, processing halts.
//    - Answers or questions are not HTML‑escaped.
// ----------------------------------------------------------------------
function processFile(filePath) {
  // Read file content (using UTF‑8 to preserve text integrity)
  const fileContent = fs.readFileSync(filePath, 'utf-8');

  // Split content into non‑empty trimmed lines.
  const lines = fileContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);

  // Validate header lines – the first two non‑empty lines.
  const categoryLine = lines[0] || '';
  const titleLine = lines[1] || '';
  if (!categoryLine.startsWith('##CATEGORY_ID=') || !titleLine.startsWith('##TITLE=')) {
    console.error(`File ${filePath} is missing valid header lines.
Please ensure the first two lines are:
   ##CATEGORY_ID=<your_category_id>
   ##TITLE=<your_display_title>`);
    return; // Abort processing for this file.
  }
  
  // Extract the category ID and display title.
  const categoryId = categoryLine.split('=')[1].trim();
  const title = titleLine.split('=')[1].trim();
  
  // Process the remaining lines as Q&A pairs.
  const contentLines = lines.slice(2);
  const qnaPairs = [];
  let currentQna = null;
  
  // The regex detects lines that start with a number, a dot, and at least one space.
  const questionRegex = /^\d+\.\s+(.+)/; 

  contentLines.forEach(line => {
    const match = line.match(questionRegex);
    if (match) {
      // Found a new question. Prior Q&A pair is pushed after trimming.
      if (currentQna) {
        currentQna.answer = currentQna.answer.trim();
        qnaPairs.push(currentQna);
      }
      currentQna = {
        question: match[1].trim(),
        answer: ''
      };
    } else if (currentQna) {
      // Append to the current answer (even if digits are present inside).
      currentQna.answer += line + ' ';
    }
    // Lines before the first detected question are ignored.
  });
  
  // Add the last Q&A pair if exists.
  if (currentQna) {
    currentQna.answer = currentQna.answer.trim();
    qnaPairs.push(currentQna);
  }
  
  // Generate the accordion HTML and wrap it in the full container.
  const accordionHTML = generateAccordionHTML(categoryId, qnaPairs);
  const finalHTML = wrapInCategoryContainer(categoryId, title, accordionHTML);
  
  // Determine the output file name by changing the extension to .handlebars.
  const baseName = path.basename(filePath, '.txt');
  const outputPath = path.join(OUTPUT_DIR, `${baseName}.handlebars`);
  
  // Synchronously write the output file.
  fs.writeFileSync(outputPath, finalHTML, 'utf-8');
  console.log(`Successfully generated partial: ${outputPath}`);
}

// ----------------------------------------------------------------------
// Main Execution: Process all .txt files in the Qapartials directory.
// ----------------------------------------------------------------------
fs.readdir(INPUT_DIR, (err, files) => {
  if (err) {
    console.error('Error reading the QApartials directory:', err);
    return;
  }
  
  // Filter only .txt files and ignore any files that are already auto‑generated.
  const inputFiles = files.filter(file => file.endsWith('.txt') && !file.endsWith('.handlebars.txt'));
  inputFiles.forEach(file => {
    const filePath = path.join(INPUT_DIR, file);
    processFile(filePath);
  });
});
